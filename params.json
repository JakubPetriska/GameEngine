{
  "name": "GameEngine",
  "tagline": "Simple game engine for Android written in Java",
  "body": "Simple game engine for Android written in Java.\r\nSupports Android 2.3 (API level 9) and up.\r\n\r\n![](https://jakubpetriska.github.io/GameEngine/images/showcase.png)\r\n\r\n![](https://jakubpetriska.github.io/GameEngine/images/sample.png)\r\n\r\nCreated as a bachelor's thesis at CTU in Prague.\r\n\r\n## Documentation\r\nComplete javadoc for engine's API can be seen [here](https://jakubpetriska.github.io/GameEngine/javadoc-0.4.1/index.html).\r\n\r\n\r\n## Coordinate system\r\nLeft-handed coordinate system with _z_ axis pointing forward, _y_ pointing up and _x_ to the right.\r\n\r\n\r\n## Tutorial\r\nIn this tutorial you will create a simple application showing only the engine content. Engine will display an object that player will be able to move using his finger.\r\n\r\nFor more examples and samples of working projects using the engine check out the _sample_ and _showcase_ project modules. These contain the sample and showcase applications respectively.\r\n\r\n\r\n### Project setup\r\nCreate new Android Studio project and either add the whole _engine_ and _android-adapter_ modules into your project, upon which module with your application will be dependent or build the engine as an AAR file and add it to your project.\r\n\r\nNow you must add the engine activity to the _AndroidManifest.xml_. In this tutorial you will add the activity as main application activity, however it does not have to be the main activity.\r\n\r\nTo add this activity, place the following code into `<application>` tag of your _AndroidManifest.xml_.\r\n\r\n```xml\r\n<activity android:name=\"com.jakubpetriska.gameengine.api.android.GameEngineActivity\">\r\n    <intent-filter>\r\n        <action android:name=\"android.intent.action.MAIN\" />\r\n        <category android:name=\"android.intent.category.LAUNCHER\" />\r\n    </intent-filter>\r\n</activity>\r\n```\r\n\r\n\r\n### Add scene\r\nTo be able to run the application a few configuration files are needed. All engine configuration files are located in the application's assets folder, specifically in _assets/gameengine_.\r\n\r\nFirst configuration file that needs to be created is _scenes.xml_ file that needs to be located on _assets/gameengine/scenes.xml_. This file defines what scenes engine can display and which scene is default. In our application default scene will always be displayed as first.\r\n\r\nCreate this file with following content:\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<scenes\r\n    defaultSceneName=\"main_scene\">\r\n    <scene\r\n        name=\"main_scene\"\r\n        sceneFilePath=\"scenes/main_scene.xml\"/>\r\n</scenes>\r\n```\r\n\r\nContent of this file says that our engine has a single scene named _main_scene_ and it is a default scene. Now there is one more thing. Every scene needs to have it's definition file. This file defines what is in the scene when it is loaded. It can be placed anywhere in the _assets/gameengine_ folder and it's path needs to be specified in the _scenes.xml_ file for every scene using the _sceneFilePath_ attribute of _<scene>_ tag. Create the _assets/gameengine/scenes/main_scene.xml_ now.\r\n\r\nGame engine's scene consists of objects with components. Objects hold things such as transformation while components add functionality such as rendering a 3D object. Scripts are also components.\r\n\r\nIn our scene there will be a cube that user will be able to move with his finger. We will create an object on the initial position of our cube that will contain two components. First component will be Mesh component, responsible for rendering the cube and second component will be the script controlling it's movement. Let's start with the cube.\r\n\r\nCopy the following code into your _main_scene.xml_:\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<scene>\r\n    <gameObjects>\r\n        <gameObject>\r\n            <transform>\r\n                <position x=\"0\" y=\"0\" z=\"10\" />\r\n            </transform>\r\n            <components>\r\n                <component type=\"mesh\">\r\n                    <params>\r\n                        <param name=\"meshPath\">cube</param>\r\n                    </params>\r\n                </component>\r\n            </components>\r\n        </gameObject>\r\n    </gameObjects>\r\n</scene>\r\n```\r\n\r\nYou can see that _<scene>_ tag contains `<gameObjects>` tag which contains all top level objects of this scene. In our scene there is only one object specified by `<gameObject>` tag in our game objects collection. Our game object contains two other tags. These are `<transform>`, containing initial position of the object and `<components>` which contains all object's components. We specify component's type and in the parameters we specify primitive that we want to render.\r\n\r\nProject can now be built so please go ahead and test it.\r\n\r\n\r\n### Control the cube\r\nApplication will use the touch input to move the cube. First we need to add new component that will control the cube and attach it to the cube's object. Create new java class and extend the _Component_ class from engine's API. Now head to your _main_scene.xml_ and add new component into the `<components>` tag. Add a _type_ attribute to the new component and put in the full class name, with package, of your new component. In our example project this line looks like this:\r\n\r\n```xml\r\n<component type=\"com.jakubpetriska.gameengine.samples.basic.CubeController\"/>\r\n```\r\n\r\nIn order to access touch input in our component we need to use the _Application_ class from engine's API. This class acts as a container for objects that provide all the important functionality. Reference to the instance of `Application` is stored in every `Component` and it can be obtained with calling the `getApplication()` method of `Component`. This is the `Component` that we'll use for controlling our cube:\r\n```java\r\nimport com.jakubpetriska.gameengine.api.Component;\r\nimport com.jakubpetriska.gameengine.api.Time;\r\nimport com.jakubpetriska.gameengine.api.Touch;\r\nimport java.util.List;\r\n\r\npublic class CubeController extends Component {\r\n\r\n    private static final float MOVEMENT_CONSTANT = 0.2f;\r\n\r\n    // Save the last touch position to calculate position deltas\r\n    private float mLastTouchX = -1;\r\n    private float mLastTouchY = -1;\r\n\r\n    @Override\r\n    public void update() {\r\n        Time time = getApplication().getTime();\r\n        List<Touch> touches = getApplication().getTouchInput().getTouches();\r\n        if (touches.size() > 0) {\r\n            // For simplicity we will always use the first running gesture\r\n            Touch touch = touches.get(0);\r\n\r\n            // Deltas need to be negated to move into the direction of touch\r\n            float touchXDelta = -(touch.getX() - mLastTouchX);\r\n            float touchYDelta = -(touch.getY() - mLastTouchY);\r\n\r\n            if (mLastTouchX != -1 && mLastTouchY != -1) {\r\n                getGameObject().transform.moveBy(\r\n                        touchXDelta * time.getTimeDelta() * MOVEMENT_CONSTANT,\r\n                        touchYDelta * time.getTimeDelta() * MOVEMENT_CONSTANT,\r\n                        0);\r\n            }\r\n\r\n            if (touch.getState() == Touch.STATE_ENDED) {\r\n                // Reset our positions when touch ends\r\n                mLastTouchX = -1;\r\n                mLastTouchY = -1;\r\n            } else {\r\n                // Save our new positions\r\n                mLastTouchX = touch.getX();\r\n                mLastTouchY = touch.getY();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nEvery _Component_ has a set of life cycle methods that can be overridden to provide component's functionality. In our `CubeController` we override the `update()` method. This method is called during every frame of the application's life. Please refer to engine's API documentation for complete list of all methods in `Component` class.\r\n\r\nTo respond to touch events and move the cube we use two objects from `Application`. These are the _Time_ object, providing time information and the `TouchInput` object, which provides information about currently running touch events.\r\n\r\n\r\n### Adding another cube\r\nTo make our game little more interesting we will put a second cube into the game to move along the first one. To do this easily we'll just add the second cube as a child object of the first cube.\r\n\r\nIn our _main_scene.xml_ add new `<children></children>` tag into our `<gameObject>` tag of our first cube. Now add the following object into the `<children>` tag:\r\n\r\n```xml\r\n<gameObject>\r\n    <transform>\r\n        <position x=\"1\" y=\"1\" z=\"1\" />\r\n    </transform>\r\n    <components>\r\n        <component type=\"mesh\">\r\n            <params>\r\n                <param name=\"meshPath\">cube</param>\r\n            </params>\r\n        </component>\r\n    </components>\r\n</gameObject>\r\n```\r\n\r\nWe do not need to add another instance of the `CubeController` component to this object because it is automatically moved by it's parent. It's transformation is only relative to it's parent's transformation.\r\n\r\nBuild and run the project. Your first application is now complete, congratulations!\r\n\r\n\r\n## License\r\n\r\n    Copyright 2016 Jakub Petriska\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}